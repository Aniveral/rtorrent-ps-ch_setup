# ~/.rtorrent.rc and enable/modify the options as needed. Remember to uncomment the options you wish to enable.


##### begin: Including PyroScope settings #####

#
# PyroScope SETTINGS
#

# Set "pyro.extended" to 1 to activate rTorrent-PS features!
# LEAVE THIS AT 0 IF YOU RUN A VANILLA rTorrent!
method.insert = pyro.extended, value|const, 1

# Set "pyro.extended.ch" to 1 to activate rTorrent-PS-CH features!
# LEAVE THIS AT 0 IF YOU DO NOT RUN IT!
method.insert = pyro.extended.ch, value|const, 1

# Set "pyro.bin_dir" to the "bin" directory where you installed the pyrocore tools!
# Make sure you end it with a "/"; if this is left empty, then the shell's path is searched.
method.insert = pyro.bin_dir, string|const, "$cat=~/bin/"

# Helper method to import specified conf file as a parameter from ~/.pyroscope/ directory.
method.insert = import.pyro.rc, simple, "import=\"$cat=~/.pyroscope/,$argument.0=\""

# Imports main pyroscope conf file
import.pyro.rc = "$cat=rtorrent-ps-,\"$system.client_version=\",.rc"

##### end: Including PyroScope settings #####



##### begin: Default connection settings #####

# Global upload and download rate in KiB (download_rate, upload_rate). "0" for unlimited.
throttle.global_down.max_rate.set_kb = 10000
throttle.global_up.max_rate.set_kb   = 2500

# Maximum and minimum number of peers to connect to per torrent while downloading (applies to the 'slowup' throttle group). (min_peers, max_peers)
throttle.min_peers.normal.set = 89
throttle.max_peers.normal.set = 100

# Same as above but for seeding completed torrents (-1 = same as downloading) (seeds per torrent) (applies to the 'slowup' throttle group). (min_peers_seed, max_peers_seed)
throttle.min_peers.seed.set = 29
throttle.max_peers.seed.set = 50

# Maximum number of simultanious uploads per torrent. (upload slots!) (applies to the 'slowup' throttle group). (max_uploads)
throttle.max_uploads.set = 15

# Maximum number of simultaneous downloads and uploads slots (global slots!) (max_downloads_global, max_uploads_global)
throttle.max_downloads.global.set = 300
throttle.max_uploads.global.set   = 300

# Throttles rates for (groups of) downloads or IP ranges. (throttle_up) These throttles borrow bandwidth from the global throttle and thus are limited by it too.
# You can assign throttles to a stopped download with Ctrl-T. The NULL throttle is a special unlimited throttle that bypasses the global throttle.
# Limits the upload rate to 600 kb/s for the slowup throttle group. 
throttle.up = slowup,600

# Set the max amount of memory space used to mapping file chunks. (max_memory_usage) This may also be set using ulimit -m where 3/4 will be allocated to file chunks.
pieces.memory.max.set = 2000M

# Limit the number of connections rtorrent can accept/make (sockets) 
network.max_open_sockets.set = 768

# Limit the number of open files rtorrent can keep open (you have to modify the system wide settings with ulimit!!!) (set_max_open_files)
network.max_open_files.set = 1999

# Limit the number simultanous of HTTP request (default 32) (set_max_open_http)
network.http.max_open.set = 99

##### end: Default connection settings #####



##### begin: Directory settings #####

# Defining directory constants
method.insert = main_dir,        string|const|private, "$cat=/mnt/Torrents/"
method.insert = sub_dir,         string|const|private, "$cat=$main_dir=,.rtorrent/"
method.insert = downloading_dir, string|const|private, "$cat=$sub_dir=,.downloading/"
method.insert = meta_dir,        string|const|private, "$cat=$sub_dir=,.completed/"
method.insert = delqueue_dir,    string|const|private, "$cat=$sub_dir=,.delqueue/"

# Default directory to save the downloaded torrents and where you should place your 'complete' data before you place your *.torrent file into the watch folder to be able to be hash checked. (directory)
directory.default.set = "$cat=$sub_dir=,incomplete/"

# Default session directory. Make sure you don't run multiple instance of rtorrent using the same session directory. Perhaps using a relative path? (session)
session.path.set = "$cat=$sub_dir=,.session"

# Watch directories for new torrents (metafiles).
# Also specifying the final directories (data_dir and meta_dir) for them, and setting:
# - high priority for the special group ; - slowup throttle for the 2nd group (rest of the torrents) ; - unsafe_data custom field for those we want to delete their data upon removal
schedule = watch_dir_1,  5, 10, "load.start=\"$cat=$downloading_dir=,rotating/*.torrent\", \"d.custom.set=data_dir,\\\"$cat=$main_dir=,rotating\\\"\", \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,rotating\\\"\", d.priority.set=3,           \"d.custom.set=unsafe_data,1\""
schedule = watch_dir_2,  5, 10, "load.start=\"$cat=$downloading_dir=,fullseed/*.torrent\", \"d.custom.set=data_dir,\\\"$cat=$main_dir=,fullseed\\\"\", \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,fullseed\\\"\", d.priority.set=3"
schedule = watch_dir_3,  5, 10, "load.start=\"$cat=$downloading_dir=,unsafe/*.torrent\",   \"d.custom.set=data_dir,\\\"$cat=$main_dir=,unsafe\\\"\",   \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,unsafe\\\"\",   d.throttle_name.set=slowup, \"d.custom.set=unsafe_data,1\""
schedule = watch_dir_4,  5, 10, "load.start=\"$cat=$downloading_dir=,various/*.torrent\",  \"d.custom.set=data_dir,\\\"$cat=$main_dir=,various\\\"\",  \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,various\\\"\",  d.throttle_name.set=slowup"
schedule = watch_dir_5,  5, 10, "load.start=\"$cat=$downloading_dir=,apps/*.torrent\",     \"d.custom.set=data_dir,\\\"$cat=$main_dir=,apps\\\"\",     \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,apps\\\"\",     d.throttle_name.set=slowup"
schedule = watch_dir_6,  5, 10, "load.start=\"$cat=$downloading_dir=,ebooks/*.torrent\",   \"d.custom.set=data_dir,\\\"$cat=$main_dir=,ebooks\\\"\",   \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,ebooks\\\"\",   d.throttle_name.set=slowup"
schedule = watch_dir_7,  5, 10, "load.start=\"$cat=$downloading_dir=,pictures/*.torrent\", \"d.custom.set=data_dir,\\\"$cat=$main_dir=,pictures\\\"\", \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,pictures\\\"\", d.throttle_name.set=slowup"
schedule = watch_dir_8,  5, 10, "load.start=\"$cat=$downloading_dir=,songs/*.torrent\",    \"d.custom.set=data_dir,\\\"$cat=$main_dir=,songs\\\"\",    \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,songs\\\"\",    d.throttle_name.set=slowup"
schedule = watch_dir_9,  5, 10, "load.start=\"$cat=$downloading_dir=,cartoons/*.torrent\", \"d.custom.set=data_dir,\\\"$cat=$main_dir=,cartoons\\\"\", \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,cartoons\\\"\", d.throttle_name.set=slowup"
schedule = watch_dir_10, 5, 10, "load.start=\"$cat=$downloading_dir=,hdtv/*.torrent\",     \"d.custom.set=data_dir,\\\"$cat=$main_dir=,hdtv\\\"\",     \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,hdtv\\\"\",     d.throttle_name.set=slowup"
schedule = watch_dir_11, 5, 10, "load.start=\"$cat=$downloading_dir=,movies/*.torrent\",   \"d.custom.set=data_dir,\\\"$cat=$main_dir=,movies\\\"\",   \"d.custom.set=meta_dir,\\\"$cat=$meta_dir=,movies\\\"\",   d.throttle_name.set=slowup"


### begin: Delete data (dir/files) for torrents that have been removed either from the UI (CTRL+dd) or the tied metafile has been removed manually or by a script, ###
#     only for torrents which have the unsafe_data custom field set or which are in the incmoplete dir (useful to delete data of stucked torrents). This allows rotating capability.
# Removes torrents from client when its metafile (torrent file) has been deleted manually or by a script. Run it every 5 seconds.
schedule = untied_torrents, 8, 5, "remove_untied="
# helper method: gets the incomplete dir data path of a torrent
method.insert  = d.get_incomplete_path, simple|private, "cat=$sub_dir=,incomplete/,$d.base_filename="
# helper method: checks whether the data of a torrent is in incomplete dir
method.insert  = d.compare_incomplete_path, simple|private, "equal={d.get_incomplete_path=,d.base_path=}"
# helper method: deletes data of a torrent and removes symlink for its metafile if it exists
method.insert  = d.remove_data, simple|private, "d.remove_symlink=;execute={rm,-rf,--,$d.base_path=}"
# Deletes data of a torrent and removes symlink for its metafile if a torrent has been removed (either from UI or manually) for torrents that have unsafe_data custom field set or which are in the incmoplete dir.
method.set_key = event.download.erased, remove_files, "branch=\"or={d.custom=unsafe_data,d.compare_incomplete_path=}\",d.remove_data="
### end: Delete data (dir/files) ###


### begin: Move data and meta (.torrent) file automatically of a finished or hashchecked torrent ( when you drop in 100% done torrent data and then have rtorrent check the data and resume seeding) ###
# insert a method with the alias 'd.get_data_path' which returns the fullpath of its final data dir
method.insert  = d.get_data_path, simple|private, "cat=$d.custom=data_dir,/,$d.base_filename="
# insert a method which returns true if the current path of the torrent data is not equal to the fullpath of its final data dir, otherwise returns false
method.insert  = d.compare_data_path, simple|private, "not=\"$equal={d.get_data_path=,d.base_path=}\""
# insert a method which: sets path of torrent to equal the value of data_dir custom field; moves data to its final place; stops and  starts the torrent (to get the torrent updating its 'base path')
#   The 'd.stop=;d.start=' methods are supposed to be together at the end of this method (used by 'download.finished' and 'download.hash_done' events)!!! Don't change it until it's working fine, it will cause a bug in tracker controller resulting stucked http/https requests!!!
method.insert  = d.move_data, simple|private, "d.directory.set=$d.custom=data_dir;execute=mv,-f,$d.base_path=,$d.custom=data_dir;d.stop=;d.start="

# insert a method to determine just the basename of a given meta (.torrent) file
method.insert  = d.get_meta_basename, simple|private, "execute.capture=sh,-c,\"echo -n \$(basename \\\"$1\\\")\",getMetaBasename,$d.tied_to_file="
# insert a method which returns the fullpath of its final meta dir
method.insert  = d.get_meta_path, simple|private, "cat=$d.custom=meta_dir,/,$d.get_meta_basename="
# insert a method which returns true if the current path of the meta (.torrent) file is not equal to the fullpath of its final meta dir, otherwise returns false
method.insert  = d.compare_meta_path, simple|private, "not=\"$equal={d.get_meta_path=,d.tied_to_file=}\""
# insert a method which: moves meta (.torrent) file to its final place; updates the tied meta file path of the torrent (to keep seeding it)
method.insert  = d.move_meta, simple|private, "execute=mv,-f,$d.tied_to_file=,$d.custom=meta_dir;d.tied_to_file.set=$d.get_meta_path="

# insert a method which returns true if neither of its fullpath of data nor its fullpath of meta (.torrent) file isn't in the final place
method.insert  = d.compare_both, simple|private, "and={d.compare_meta_path=,d.compare_data_path=}"
# insert a method which will move both data and meta (.torrent) file: moves meta (.torrent) file; moves data; saves the session of it
method.insert  = d.move_both, simple|private, "d.move_meta=;d.move_data=;d.save_full_session="
# insert a method wich will move both data and meta (.torrent) file if neither of them is in the final place
method.insert  = d.move_both_check, simple|private, "branch=d.compare_both=,d.move_both="
# finally, set a key with the name 'move_both_f' that is triggered by the finished event: moves both data and meta (.torrent) file when it's finished
method.set_key = event.download.finished, move_both_f, "d.move_both_check="
# finally, set a key with the name 'move_both_h' that is triggered by the hash_done event: moves both data and meta (.torrent) file of a completed torrent when it's 100% hashchecked
method.set_key = event.download.hash_done, move_both_h, "branch=d.complete=,d.move_both_check="
### end: Move data and meta (.torrent) file automatically ###


### begin: Helper methods to move data and meta (.torrent) file manually ###
# helper method: checks existence of a directory, file, symlink
method.insert  = check_object.value, simple|private, "execute.capture=bash,-c,\"$cat=\\\"test -\\\",$argument.2=,\\\" \\\\\\\"\\\",$argument.0=,$argument.1=,\\\"\\\\\\\" && echo -n 1 || echo -n\\\"\""
# helper method: displays error if an object doesn't exist
method.insert  = check_object.error.print, simple|private, "print=\"$cat=Error\\\\\ during\\\\\ moving\\\\\ ,$argument.2=,!\\\\\ No\\\\\ such\\\\\ ,$argument.3=,:\\\\\ ,$argument.0=,$argument.1=\""

# Dealing with delqueue dir entries and attribute
# Usage: d.add_to_delqueue=  |  d.remove_from_delqueue=  |  d.fix_delqueue_flag=
# helper method: get delqueue symlink name
method.insert  = d.get_delqueue_symlink_name, simple|private, "cat=$delqueue_dir=,$d.get_meta_basename="
# helper method: set/unset delqueue attrib
method.insert  = d.delqueue.set, simple|private, "d.custom.set=delqueue,$argument.0=; d.save_full_session="
# helper method: set delqueue attrib and create symlink
method.insert  = d.delqueue.set_create, simple|private, "d.delqueue.set=1; execute=ln,-sf,$d.tied_to_file=,$d.get_delqueue_symlink_name="
# adds torrent to delqueue if it has the unsafe_data flag by creating a symlink in delqueue dir to its metafile
method.insert  = d.add_to_delqueue, simple, "branch=d.custom=unsafe_data,d.delqueue.set_create="
# helper method: removes symlink (if it exists) for metafile from delqueue dir
method.insert  = d.remove_symlink, simple|private, "branch=\"check_object.value=$delqueue_dir=,$d.get_meta_basename=,L\",\"execute=rm,-f,--,$d.get_delqueue_symlink_name=\""
# removes torrent from delqueue by deleting its symlink (if it exists) from delqueue dir
method.insert  = d.remove_from_delqueue, simple, "d.delqueue.set=; d.remove_symlink="
# fixes delqueue flag: apply if unsafe_data flag and symlink in delqueue dir exists, remove it otherwise
method.insert  = d.fix_delqueue_flag, simple, "branch=\"and={d.custom=unsafe_data,\\\"check_object.value=$delqueue_dir=,$d.get_meta_basename=,L\\\"}\",d.delqueue.set=1,d.delqueue.set="
# run the above d.fix_delqueue_flag every day at 1:18 AM, useful if symlinks are sometimes created manually or by a script in delqueue dir
schedule = fix_delqueue_flag, 1:19:00, 24:00:00, "d.multicall2=main,d.fix_delqueue_flag="

# Move a finished, stucked meta file from the queue dir into its final place (thanks to the simetimes missing meta_dir custom field value, rtorrent bug?)
# Usage: 'd.move_meta_to=various'
# helper method: sets the missing meta_dir custom field value to the fullpath of the value of the argument and moves the meta (.torrent) file
method.insert  = d.move_meta_to.helper, simple|private, "d.custom.set=meta_dir,\"$cat=$meta_dir=,$argument.0=\";d.move_meta="
# helper method: calls the 'd.move_meta_to.helper' method which will move the meta (.torrent) file if the required directory exist, otherwise prints out an error
method.insert  = d.move_meta_to.check_object, simple|private, "branch=\"check_object.value=$meta_dir=,$argument.0=,d\",d.move_meta_to.helper=$argument.0=,\"check_object.error.print=$meta_dir=,$argument.0=,metafile,directory\""
# helper method: prints out an error message when the meta_dir custom field value exists
method.insert  = d.move_meta_to.print, simple|private, "print={Metadir\\\ is\\\ already\\\ set:\\\ ,$d.custom=meta_dir}"
# moves the finished, stucked meta file if there isn't any error, it receives 1 argument: dirname
method.insert  = d.move_meta_to, simple, "branch=d.complete=,\"d.move_meta_to.check_object=$argument.0=\""

# Move data (can be partially downloaded) and meta (.torrent) file of a torrent into another directories at the same time and update all necessary attributes of it. It receives 4 arguments: dirname,specialgroup,unsafe_data,delqueue
# Usage: e.g. 'd.move_to=rotating,1,1,' / 'd.move_to=rotating,1,1,1' or 'd.move_to=fullseed,1,,' or 'd.move_to=unsafe,,1,' / 'd.move_to=unsafe,,1,1' or 'd.move_to=various,,,'
# helper method: sets the required attributes only for torrents in special group (removes throttle group; sets priority to high)
method.insert  = d.modify_rest_special, simple|private, "d.throttle_name.set=;d.priority.set=3"
# helper method: sets the required attributes only for torrents in the 2nd group (rest) (sets slowup throttle group; sets priority to normal)
method.insert  = d.modify_rest_slowup, simple|private, "d.throttle_name.set=slowup;d.priority.set=2"
# helper method: decides which remaining helper method should be called based upon the 3rd argument and calls it
method.insert  = d.is_special_group, simple|private, "branch=argument.0=,d.modify_rest_special=,d.modify_rest_slowup="
# helper method: sets everything it can and calls the other helper methods for the rest (stops it; sets the remaining attributes (throttle group, priority) based open the 3rd argument; sets the new data and meta dirs based open the 1st argument; tries to move both data and meta; modifies the new slot values based open the 3rd argument; sets unsafe_data custom field value based open the 2nd argument; saves the session of it)
method.insert  = d.move_to.helper, simple|private, "d.stop=;d.is_special_group=$argument.1=;d.custom.set=data_dir,\"$cat=$main_dir=,$argument.0=\";d.custom.set=meta_dir,\"$cat=$meta_dir=,$argument.0=\";d.move_both_check=;d.modify_slots_both=;branch=argument.2=,\"d.custom.set=unsafe_data,1\",\"d.custom.set=unsafe_data,\";branch=argument.3=,d.add_to_delqueue=,d.remove_from_delqueue="
# helper method: calls the 'd.move_to.helper' method which will does the job if the required meta directory also exists, otherwise prints out an error
method.insert  = d.move_to.check_meta_dir, simple|private, "branch=\"check_object.value=$meta_dir=,$argument.0=,d\",\"d.move_to.helper=$argument.0=,$argument.1=,$argument.2=,$argument.3=\",\"check_object.error.print=$meta_dir=,$argument.0=,metafile,directory\""
# helper method: calls the 'd.move_to.check_meta_dir' method which will check the meta dir if the required data directory exists, otherwise prints out an error
method.insert  = d.move_to.check_data_dir, simple|private, "branch=\"check_object.value=$main_dir=,$argument.0=,d\",\"d.move_to.check_meta_dir=$argument.0=,$argument.1=,$argument.2=,$argument.3=\",\"check_object.error.print=$main_dir=,$argument.0=,data,directory\""
# moves data (can be partially downloaded) and meta (.torrent) file if there isn't any error, it receives 4 arguments: dirname,specialgroup,unsafe_data,delqueue
method.insert  = d.move_to, simple, "d.move_to.check_data_dir=$argument.0=,$argument.1=,$argument.2=,$argument.3="
### end: Helper methods to move data and meta (.torrent) file manually ###

##### end: Directory settings #####



##### begin: Favoring special group of torrents over the rest #####

# Method to modify the peers_min, peers_max, max_uploads values of special torrents for both downloading and uploading
method.insert  = d.modify_slots_special, simple|private, "d.peers_min.set=99;d.peers_max.set=100;d.uploads_max.set=50"
# Method to modify the other group values as well when a hashcheck is finished
method.insert  = d.modify_slots_slowup, simple|private, "d.peers_min.set=29;d.peers_max.set=50;d.uploads_max.set=15"
# Modify only the special group values when a new torrent is added for downloading
method.set_key = event.download.inserted_new, modify_slots_special, "branch={not=$d.throttle_name=,d.modify_slots_special=}"
method.insert  = d.modify_slots_both, simple, "branch={not=$d.throttle_name=,d.modify_slots_special=,d.modify_slots_slowup=}"
# Modify both group values when torrent is added for hashchecking or rtorrent is restarted
method.set_key = event.download.hash_done, modify_slots_hashchecked_both, "branch=d.complete=,d.modify_slots_both=}"

# helper method: gets one of the below info with the help of getLimits.sh script (Variables are inside the script, you have to edit those values there!)
method.insert = get_limit, simple|private, "execute.capture=\"$cat=$pyro.bin_dir=,getLimits.sh\",$argument.0=,$argument.1=,$argument.2=,$argument.3="
# Dynamically adjusts the 2nd group (slowup throttle) uprate (upload speed) to always leave enough bandwidth to the 1st main group. (More info in getLimits.sh script.)
schedule      = adjust_throttle_slowup, 14, 20, "throttle.up=slowup,\"$get_limit=$cat=up,$convert.kb=$throttle.global_up.rate=,$convert.kb=$throttle.up.rate=slowup\""
# Dynamically adjusts the global download rate to always leave enough bandwidth to the 1st main group upload rate. It's good for async connection (e.g. ADSL) where upload speed can be slowed down if download speed is close to max. Comment it out if you don't need it.
schedule      = adjust_throttle_global_down_max_rate, 54, 60, "throttle.global_down.max_rate.set_kb=\"$get_limit=$cat=down,$convert.kb=$throttle.global_up.rate=,$convert.kb=$throttle.up.rate=slowup\""
# Helper method to display the current rate information: after CTRL+x , you can use: i= . It displays: MainUpRate: 1440 , ThrottleUpRate: 92 , ThrottleLimit: 100
method.insert = i, simple, "print=\"$get_limit=$cat=info,$convert.kb=$throttle.global_up.rate=,$convert.kb=$throttle.up.rate=slowup,$convert.kb=$throttle.up.max=slowup\""

##### end: Favoring special group of torrents over the rest #####



##### begin: UI enhancements (the rest is in the other included config file) #####

# SORT the MAIN view by DOWNLOADED TIME
# Helper methods to list of main items by the date desc their torrent file was downloaded, Store time when torrent file was downloaded in a custom field (tm_downloaded)
method.insert     = d.tm_downloaded, simple, "execute.capture=sh,-c,\"echo -n \$(stat -c %Y \\\"$1\\\")\",getDownloadedDate,$d.tied_to_file="
method.insert     = d.tm_downloaded.set, simple|private, "d.custom.set=tm_downloaded,$cat=$d.tm_downloaded=;d.save_full_session="
method.set_key    = event.download.inserted_new, set_downloaded_date, "d.tm_downloaded.set="
view.sort_current = main,greater=d.custom=tm_downloaded

##### end: UI enhancement #####



##### begin: Other enhancements #####

# Display any time value in human readable format (useful for verifying value inside rtorrent). Usage: hrf_time=<<timefield>> (e.g.: hrf_time=$d.creation_date=)
# helper method: to display any time field (e.g. d.creation_date= , d.custom=tm_last_scrape) in human readable format
method.insert = hrf_time.helper, simple|private, "print=\"$cat={$convert.date=$argument.0=, \\\" \\\", $convert.time=$argument.0=}\""
# method to display any time field in human readable format if the value exists (e.g.: 30/06/2013 23:47:33)
method.insert = hrf_time, simple, "branch={argument.0=,hrf_time.helper=$argument.0=,print=}"

# Regularly update scrape information for all torrents (even stopped ones), it won't affect the operation of rtorrent, but nice to have these values updated.
# This info is only updated when rtorrent starts or a torrent is added by default.
# Try to balance calls to not fire them up at the same time (since multiscraping isn't implemented in libtorrent). check for update every 5 minutes and distinguish between 2 groups:
#   - transferring (uploading and/or downloading) torrents: update in every 10 minutes
#   - non-transferring torrents: update in every 12 hours
# helper method: sets current time in a custom field (tm_last_scrape) and saves session
method.insert = d.last_scrape.set, simple|private, "d.custom.set=tm_last_scrape,$cat=$system.time=; d.save_full_session="
# helper method: sends the scrape request and sets the tm_last_scrape timestamp and saves session
method.insert = d.last_scrape.send_set, simple, "d.tracker.send_scrape=0;d.last_scrape.set="
# helper method: decides whether the required time interval (with the help of an argument) has passed and if so calls the above method
method.insert = d.last_scrape.check_elapsed, simple|private, "branch={(elapsed.greater,$d.custom=tm_last_scrape,$argument.0=),d.last_scrape.send_set=}"
# helper method: checks for non-existing/empty custom field to be able to test its validity later
method.insert = d.last_scrape.check, simple|private, "branch={d.custom=tm_last_scrape,d.last_scrape.check_elapsed=$argument.0=,d.last_scrape.send_set=}"
# helper method: decides whether a torrent transferring data or not
method.insert = d.transferring.check, simple|private, "or={d.up.rate=,d.down.rate=}"
# sets custom field (tm_last_scrape) to current time only for torrents just has been added (skips setting time on purpose when rtorrent started)
method.set_key = event.download.inserted_new, last_scrape_i, "d.last_scrape.set="
# check for update every 5 minutes (300 sec) and update scrape info for transferring torrents in every 10 minutes (600-20=580 sec) and for non-transferring ones in every 12 hours (43200-20=43180 sec)
schedule = last_scrape_t, 300, 300, "d.multicall2=main,\"branch=$d.transferring.check=,d.last_scrape.check=580,d.last_scrape.check=43180\""

##### end: Other enhancements #####



##### begin: Other settings #####

# Close torrents when diskspace is low.
schedule = low_diskspace, 120, 120, close_low_diskspace=1000M

# The ip address the listening socket and outgoing connections is bound to. (bind)
network.bind_address.set = 192.168.1.8

# The ip address reported to the tracker. (ip) And alternative calls to bind and ip that should handle dynamic ip's.
schedule = ip_tick, 0, 1800, network.local_address.set=chros73.no-ip.org

# Port range to use for listening. (port_range)
network.port_range.set = 62820-62820

# Set whether the client should try to connect to UDP trackers
#trackers.use_udp.set = yes

# Enable DHT support for trackerless torrents or when all trackers are down. May be set to "disable" (completely disable DHT), "off" (do not start DHT),
# "auto" (start and stop DHT as needed), or "on" (start DHT immediately). The default is "off". For DHT to work, a session directory must be defined.
#dht.mode.set = auto

# UDP port to use for DHT
#dht.port.set = 62882

# Enable/disable peer exchange for torrents that aren't marked private. Disabled by default. (peer_exchange)
#protocol.pex.set = no

# Check hash for finished torrents. Might be usefull until the bug is fixed that causes lack of diskspace not to be properly reported. (check_hash)
pieces.hash.on_completion.set = no

# Adding support to SSL trackers and peers (http_capath)
network.http.capath.set = /etc/ssl/certs

# CURL options to add support for nonofficial SSL trackers and peers
network.http.ssl_verify_host.set = 0
network.http.ssl_verify_peer.set = 0

# CURL option to lower DNS timeout (default: 60)
network.http.dns_cache_timeout.set = 25

# Encryption options (encryption), set to none (default) or any combination of the following: allow_incoming, try_outgoing, require, require_RC4, enable_retry, prefer_plaintext
# The example value allows incoming encrypted connections, starts unencrypted outgoing connections but retries with encryption if they fail, preferring plaintext to RC4 encryption after the encrypted handshake
protocol.encryption.set = allow_incoming,prefer_plaintext,enable_retry

# SCGI socket and make it world writeable when rtorrent starts (otherwise apps can't connect to it since it was started by a normal user) (scgi_local)
network.scgi.open_local = /tmp/.rtorrent.sock
schedule                = chmod_scgi_socket, 0, 0, "execute=chmod,777,/tmp/.rtorrent.sock"

# for non english chars (encoding_list)
encoding.add = UTF-8

# default for network.xmlrpc.size_limit : 524288 (xmlrpc_size_limit)
network.xmlrpc.size_limit.set = 2M

# Set the umask for this process, which is applied to all files created by the program.
system.umask.set = 022

##### end: Other settings #####


